<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScriptパフォーマンス最適化術：早いコードは美しい</title>
    <style>
        /* Google Fonts */
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap');

        /* 基本スタイル */
        :root {
            --primary-color: #005a9c;
            --primary-hover: #004a80;
            --secondary-color: #3498db;
            --background-color: #f8f9fa;
            --card-background: #ffffff;
            --text-color: #343a40;
            --heading-color: #2c3e50;
            --border-color: #e9ecef;
            --shadow-color: rgba(0, 90, 156, 0.1);
        }

        body {
            font-family: 'Noto Sans JP', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.8;
            margin: 0;
            padding: 0;
        }

        .container {
            max-width: 960px;
            margin: 0 auto;
            padding: 1rem;
        }

        /* ヘッダー */
        header {
            text-align: center;
            padding: 4rem 1rem;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            border-radius: 0 0 20px 20px;
            margin-bottom: 3rem;
        }

        header h1 {
            font-size: 2.8rem;
            margin-bottom: 0.5rem;
            font-weight: 700;
        }

        header p {
            font-size: 1.1rem;
            max-width: 700px;
            margin: 0 auto;
            opacity: 0.9;
        }

        /* 見出し */
        h2, h3, h4 {
            color: var(--heading-color);
            font-weight: 700;
        }

        h2 {
            font-size: 2rem;
            border-bottom: 3px solid var(--primary-color);
            padding-bottom: 0.5rem;
            margin-top: 0;
            display: flex;
            align-items: center;
            gap: 0.8rem;
        }

        h3 {
            font-size: 1.5rem;
            margin-top: 2.5rem;
        }
        
        h4 {
            font-size: 1.2rem;
            margin-top: 2rem;
            margin-bottom: 0.5rem;
        }

        /* カード風セクション */
        .card {
            background: var(--card-background);
            border-radius: 12px;
            padding: 2rem 2.5rem;
            margin-bottom: 2.5rem;
            box-shadow: 0 8px 25px var(--shadow-color);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 30px var(--shadow-color);
        }

        /* コード表示 */
        pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 1.5rem;
            border-radius: 8px;
            overflow-x: auto;
            font-size: 0.95em;
            line-height: 1.6;
            min-height: 100px;
        }

        code {
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
        }

        /* 用語解説 */
        dfn {
            font-style: normal;
            border-bottom: 2px dotted var(--secondary-color);
            cursor: help;
            position: relative;
        }

        /* デモエリア */
        .demo-box {
            margin-top: 2rem;
            padding: 2rem;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: #fdfdfd;
        }
        
        .demo-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
        }
        
        .demo-column p {
            min-height: 80px;
        }

        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            width: 100%;
        }

        button:hover {
            background-color: var(--primary-hover);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
        }

        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
            transform: translateY(0);
            box-shadow: none;
        }

        #run-slow-dom, #run-slow-loop, #run-normal-load {
            background-color: #e74c3c;
        }
        #run-slow-dom:hover, #run-slow-loop:hover, #run-normal-load:hover {
            background-color: #c0392b;
        }

        #run-fast-dom, #run-fast-loop, #run-lazy-load {
            background-color: #2ecc71;
        }
        #run-fast-dom:hover, #run-fast-loop:hover, #run-lazy-load:hover {
            background-color: #27ae60;
        }

        #reset-all-demos {
            background-color: #7f8c8d;
        }
        #reset-all-demos:hover {
            background-color: #616a6b;
        }

        .result-display {
            margin-top: 1.5rem;
            padding: 1rem;
            background-color: var(--border-color);
            border-radius: 8px;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
            min-height: 2.5em;
            transition: background-color 0.3s;
            font-weight: 700;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* 画像遅延読み込みデモ用スタイル */
        .image-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 1rem;
            margin-top: 1.5rem;
            padding: 1rem;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            min-height: 300px;
            background: #f0f0f0;
        }
        
        .image-grid img {
            width: 100%;
            height: 150px;
            object-fit: cover;
            border-radius: 8px;
            background-color: #e0e0e0;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }

        .image-grid img.loaded {
            opacity: 1;
        }
        
        /* フッター */
        footer {
            text-align: center;
            padding: 2rem 1rem;
            margin-top: 2rem;
            color: #7f8c8d;
            font-size: 0.9em;
        }


        /* レスポンシブ対応 */
        @media (max-width: 768px) {
            header h1 { font-size: 2.2rem; }
            h2 { font-size: 1.8rem; }
            .card { padding: 1.5rem; }
            .demo-grid { grid-template-columns: 1fr; }
            .demo-column p { min-height: auto; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>JavaScriptパフォーマンス最適化術</h1>
            <p>🚀 早いコードは美しい。ユーザーに愛され、未来の自分も助ける最適化の世界へようこそ！</p>
        </header>

        <main>
            <section class="card">
                <h2>🤔 パフォーマンスとは何か？</h2>
                <p>Webサイトの「パフォーマンス」とは、単に「速さ」のことだけではありません。主に3つの側面があります。</p>
                <ul>
                    <li><strong>実行速度:</strong> JavaScriptのコードが処理を完了するまでの時間。計算やデータ処理の速さです。</li>
                    <li><strong>反応速度:</strong> ユーザーがボタンをクリックしたり、入力したりしたときに、画面が反応を返すまでの時間。これが遅いと「固まった？」と感じさせてしまいます。</li>
                    <li><strong>描画速度:</strong> ページが画面に表示されるまでの時間や、アニメーションの滑らかさ。これが遅いと、ページの表示がもたついたり、カクカクした動きになったりします。</li>
                </ul>
                <p>例えば、検索ボタンを押しても10秒も結果が返ってこないサイト、スクロールするたびにカクつくブログ記事…そんな経験はありませんか？ユーザーは待ってくれません。パフォーマンスの低いサイトは、すぐに閉じられてしまうのです。</p>
            </section>

            <section class="card">
                <h2>🐢 よくある「遅いコード」と改善例</h2>
                <p>初心者の頃に書いてしまいがちな非効率なコードと、その改善方法を並べて見ていきましょう。</p>
                
                <h3>例1：ループ処理の中での<dfn title="Document Object Modelの略。HTML要素をJavaScriptで操作するための仕組み。">DOM</dfn>操作</h3>
                <p><strong>なぜ遅いのか？:</strong> DOM操作は、JavaScriptの計算に比べて非常にコストの高い処理です。ブラウザは `innerHTML` が変更されるたびに、ページの構造を再計算し、画面を再描画しようとします。これを何度も繰り返せば、当然遅くなります。</p>
                
                <h4>🐢 遅いコード</h4>
                <pre><code>for (let i = 0; i < 2000; i++) {
  // ループのたびに画面を書き換えている！
  list.innerHTML += `&lt;li&gt;アイテム ${i}&lt;/li&gt;`;
}</code></pre>

                <h4>🚀 改善コード</h4>
                <pre><code>let htmlString = '';
for (let i = 0; i < 2000; i++) {
  // まずは高速な文字列結合だけを行う
  htmlString += `&lt;li&gt;アイテム ${i}&lt;/li&gt;`;
}
// ループが終わってから、最後に一度だけ画面を書き換える
list.innerHTML = htmlString;</code></pre>
                <p><strong>改善のポイント:</strong> コストの高いDOM操作はループの外に出し、回数を最小限（この場合は1回）に抑えるのが鉄則です。</p>

                <h3>例2：ループ条件でのプロパティへの繰り返しアクセス</h3>
                <p><strong>なぜ遅いのか？:</strong> `array.length` のようなプロパティへのアクセスは、一見すると高速に思えます。しかし、ループで何百万回も繰り返されると、そのわずかなコストが積み重なって無視できない差になることがあります。</p>
                
                <h4>🐢 遅いコード</h4>
                <pre><code>for (let i = 0; i < largeArray.length; i++) {
  // ループのたびに .length にアクセスしている
  // ...
}</code></pre>

                <h4>🚀 改善コード</h4>
                <pre><code>const len = largeArray.length; // 先に長さを取得して変数に保存
for (let i = 0; i < len; i++) {
  // 変数を参照するので、プロパティへのアクセスが不要になる
  // ...
}</code></pre>
                <p><strong>改善のポイント:</strong> ループ内で変化しない値は、ループの前に一度だけ取得して変数に保存（キャッシュ）しておきましょう。これにより、ループ中の無駄な処理をなくせます。</p>
            </section>

            <section class="card" id="demo-area">
                <h2>⏱️ 比較体験：自分で計測してみよう！</h2>
                <p>百聞は一見にしかず。実際にコードを動かして、その速さを体感してみましょう。<br>
                ボタンを押すと、各処理の実行時間がコンソールと、この下に表示されます。</p>

                <div class="demo-box">
                    <h3>デモ1：実行速度（DOM操作）</h3>
                    <div class="demo-grid">
                        <div class="demo-column">
                            <h4>🐢 遅いコード</h4>
                            <p>ループの中で毎回DOMを操作するため、ブラウザの再描画が頻繁に発生し、処理が非常に遅くなります。</p>
                            <pre><code>for (let i = 0; i < 2000; i++) {
  dummy.innerHTML += '&lt;li&gt;...&lt;/li&gt;';
}</code></pre>
                            <button id="run-slow-dom">実行</button>
                            <div id="result-dom-slow" class="result-display"></div>
                        </div>
                        <div class="demo-column">
                            <h4>🚀 速いコード</h4>
                            <p>HTML文字列を一旦変数に溜め込み、最後に一度だけDOMを操作するため、再描画が1回で済み、非常に高速です。</p>
                            <pre><code>let str = '';
for (let i = 0; i < 2000; i++) {
  str += '&lt;li&gt;...&lt;/li&gt;';
}
dummy.innerHTML = str;</code></pre>
                            <button id="run-fast-dom">実行</button>
                            <div id="result-dom-fast" class="result-display"></div>
                        </div>
                    </div>
                </div>

                <div class="demo-box">
                    <h3>デモ2：実行速度（重いループ）</h3>
                    <div class="demo-grid">
                        <div class="demo-column">
                            <h4>🐢 遅いコード</h4>
                            <p>ループのたびに `largeArray.length` にアクセスするため、わずかなコストが積み重なります。</p>
                            <pre><code>for (let i = 0; i < 500万; i++) {
  // ...
}</code></pre>
                            <button id="run-slow-loop">実行</button>
                            <div id="result-loop-slow" class="result-display"></div>
                        </div>
                        <div class="demo-column">
                            <h4>🚀 速いコード</h4>
                            <p>ループの前に長さを変数にキャッシュ（保存）しておくことで、ループ中の無駄なアクセスをなくします。</p>
                            <pre><code>const len = largeArray.length;
for (let i = 0; i < len; i++) {
  // ...
}</code></pre>
                            <button id="run-fast-loop">実行</button>
                            <div id="result-loop-fast" class="result-display"></div>
                        </div>
                    </div>
                </div>
                
                <div class="demo-box">
                    <h3>デモ3：描画速度（画像の遅延読み込み）</h3>
                    <p>ページ表示と同時に全画像を読み込むのと、スクロールに応じて表示領域に入った画像だけを読み込むのでは、どちらが快適でしょうか？</p>
                    <div class="demo-grid">
                        <div class="demo-column">
                            <h4>🐢 通常読み込み</h4>
                            <p>ページを開いた瞬間に、表示されていない画像も含めて全ての読み込みを開始します。画像が多いと初期表示が遅くなります。</p>
                            <button id="run-normal-load">実行</button>
                        </div>
                        <div class="demo-column">
                            <h4>🚀 遅延読み込み</h4>
                            <p>まずプレースホルダーを表示し、スクロールして画像が画面に近づいてから初めて、本当の画像の読み込みを開始します。</p>
                            <button id="run-lazy-load">実行</button>
                        </div>
                    </div>
                    <div id="image-container" class="image-grid">
                        <p style="color: #777;">上のボタンを押して、画像の読み込み方を試してください。</p>
                    </div>
                </div>
                
                <div class="demo-box" style="text-align: center;">
                    <button id="reset-all-demos" style="width: auto;">全デモをリセット</button>
                </div>

            </section>

            <section class="card">
                <h2>💡 プロも使う最適化習慣5選</h2>
                <p>日々のコーディングで少し意識するだけで、パフォーマンスは大きく変わります。初心者でも今日からできる習慣を5つ紹介します。</p>
                <ol>
                    <li><strong>DOM操作は慎重に:</strong> 画面の書き換えは重い処理だと常に意識し、回数を減らせないか考えましょう。</li>
                    <li><strong>ループを意識する:</strong> 何千、何万回と繰り返されるループの中の処理は、わずかな非効率が大きな遅延につながります。ループ内では重い処理を避けましょう。</li>
                    <li><strong>計算結果を使い回す (キャッシュ):</strong> ループ内外に関わらず、同じ計算を何度も行うのは無駄です。結果を変数に保存して使い回しましょう。</li>
                    <li><strong>イベント発火を制御する:</strong> `scroll` や `mousemove` のような頻繁に発生するイベントの処理は、<dfn title="処理を間引くテクニック。例えば、スクロールイベントで0.2秒ごとに処理を実行するなど。">スロットリング</dfn>や<dfn title="最後のイベント発生から一定時間後に処理を一度だけ実行するテクニック。入力完了後の検索などで使われる。">デバウンス</dfn>といったテクニックで実行回数を制御できないか検討しましょう。（これは少し発展的な内容です）</li>
                    <li><strong>気軽に計測する:</strong>「どっちが速いかな？」と疑問に思ったら、`console.time()` ですぐに計測する癖をつけましょう。勘に頼らず、事実に基づいて判断することが重要です。</li>
                </ol>
            </section>

            <section class="card">
                <h2>✨ まとめ：速いコードは、すべてを良くする</h2>
                <p>パフォーマンスを最適化することは、単なる自己満足ではありません。多くのメリットをもたらします。</p>
                <ul>
                    <li><strong>ユーザー体験の向上:</strong> サクサク動くWebサイトは、ユーザーの満足度を高め、離脱率を下げます。</li>
                    <li><strong>省エネルギー:</strong> 無駄な計算を減らすことは、CPUの消費電力を抑えることにつながります。特にモバイルデバイスではバッテリー持ちに直結します。</li>
                    <li><strong>保守性の向上:</strong> パフォーマンスを意識したコードは、結果的に無駄がなく、きれいで読みやすいコードになることが多いです。</li>
                </ul>
                <p>速いコードは、美しく、そしてユーザーにも地球にも優しいコードです。ぜひ今日から、パフォーマンスを意識したコーディングを心がけてみてください。</p>
            </section>
        </main>
        
        <footer>
            <p>製作時間: 400分</p>
        </footer>
    </div>
    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- 要素の取得 ---
            const slowDomBtn = document.getElementById('run-slow-dom');
            const fastDomBtn = document.getElementById('run-fast-dom');
            const resultDomSlowDiv = document.getElementById('result-dom-slow');
            const resultDomFastDiv = document.getElementById('result-dom-fast');

            const slowLoopBtn = document.getElementById('run-slow-loop');
            const fastLoopBtn = document.getElementById('run-fast-loop');
            const resultLoopSlowDiv = document.getElementById('result-loop-slow');
            const resultLoopFastDiv = document.getElementById('result-loop-fast');
            
            const normalLoadBtn = document.getElementById('run-normal-load');
            const lazyLoadBtn = document.getElementById('run-lazy-load');
            const imageContainer = document.getElementById('image-container');
            
            const resetAllDemosBtn = document.getElementById('reset-all-demos');

            // --- 定数 (負荷を調整) ---
            const DOM_ITERATIONS = 2000; // ストレスなく体感できる回数
            const LOOP_ITERATIONS = 5000000; // 差が分かりやすいように調整
            const IMAGE_COUNT = 50; // デモ用の画像数
            const largeArray = new Array(LOOP_ITERATIONS).fill(0);

            let imageObserver = null;

            // --- UI制御用の関数 ---
            const setButtonsState = (buttons, disabled) => {
                buttons.forEach(btn => btn.disabled = disabled);
            };

            // --- 共通処理関数 ---
            const runTest = (testFunction, resultElement, buttonToDisable) => {
                buttonToDisable.disabled = true;
                resultElement.textContent = '処理中...';

                setTimeout(() => {
                    try {
                        const startTime = performance.now();
                        const testName = testFunction.name;
                        console.time(testName);
                        
                        testFunction(); // 実際の処理を実行

                        const endTime = performance.now();
                        console.timeEnd(testName);
                        const duration = endTime - startTime;
                        resultElement.textContent = `完了！ ${duration.toFixed(2)} ms`;
                    } catch (e) {
                        console.error(e);
                        resultElement.textContent = 'エラーが発生しました。';
                    } finally {
                        buttonToDisable.disabled = false;
                    }
                }, 10);
            };

            // --- デモ1：DOM操作 ---
            function slowDomTest() {
                const dummyElement = document.createElement('ul');
                for (let i = 0; i < DOM_ITERATIONS; i++) {
                    dummyElement.innerHTML += `<li>アイテム ${i}</li>`;
                }
            }
            function fastDomTest() {
                let htmlString = '';
                for (let i = 0; i < DOM_ITERATIONS; i++) {
                    htmlString += `<li>アイテム ${i}</li>`;
                }
                const dummyElement = document.createElement('ul');
                dummyElement.innerHTML = htmlString;
            }

            // --- デモ2：ループ処理 ---
            function slowLoopTest() {
                let dummyValue = 0;
                for (let i = 0; i < largeArray.length; i++) {
                    dummyValue += i;
                }
            }
            function fastLoopTest() {
                const len = largeArray.length;
                let dummyValue = 0;
                for (let i = 0; i < len; i++) {
                    dummyValue += i;
                }
            }
            
            // --- デモ3：画像の遅延読み込み ---
            const createImage = (isLazy, index) => {
                const img = document.createElement('img');
                const imageUrl = `https://placehold.co/300x300/3498db/ffffff?text=Image+${index+1}`;
                if (isLazy) {
                    img.dataset.src = imageUrl;
                    img.src = 'https://placehold.co/30x30/e0e0e0/e0e0e0?text=...'; // プレースホルダー
                } else {
                    img.src = imageUrl;
                    img.onload = () => img.classList.add('loaded');
                }
                return img;
            };

            const setupImages = (isLazy) => {
                imageContainer.innerHTML = '';
                setButtonsState([normalLoadBtn, lazyLoadBtn], true);

                for (let i = 0; i < IMAGE_COUNT; i++) {
                    imageContainer.appendChild(createImage(isLazy, i));
                }

                if (isLazy) {
                    setupLazyLoadObserver();
                }
                 setButtonsState([normalLoadBtn, lazyLoadBtn], false);
            };
            
            const setupLazyLoadObserver = () => {
                if(imageObserver) {
                    imageObserver.disconnect();
                }

                imageObserver = new IntersectionObserver((entries, observer) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const img = entry.target;
                            img.src = img.dataset.src;
                            img.onload = () => img.classList.add('loaded');
                            observer.unobserve(img);
                        }
                    });
                }, { rootMargin: "0px 0px 200px 0px" }); // 画面下200pxまで来たら読み込み開始

                const images = imageContainer.querySelectorAll('img[data-src]');
                images.forEach(img => imageObserver.observe(img));
            };

            const resetAllDemos = () => {
                // デモ1のリセット
                resultDomSlowDiv.textContent = '';
                resultDomFastDiv.textContent = '';
                // デモ2のリセット
                resultLoopSlowDiv.textContent = '';
                resultLoopFastDiv.textContent = '';
                // デモ3のリセット
                if(imageObserver) imageObserver.disconnect();
                imageContainer.innerHTML = '<p style="color: #777;">上のボタンを押して、画像の読み込み方を試してください。</p>';
                
                console.clear();
                console.log("全デモをリセットしました。");
            };

            // --- イベントリスナーの設定 ---
            slowDomBtn.addEventListener('click', () => runTest(slowDomTest, resultDomSlowDiv, slowDomBtn));
            fastDomBtn.addEventListener('click', () => runTest(fastDomTest, resultDomFastDiv, fastDomBtn));
            
            slowLoopBtn.addEventListener('click', () => runTest(slowLoopTest, resultLoopSlowDiv, slowLoopBtn));
            fastLoopBtn.addEventListener('click', () => runTest(fastLoopTest, resultLoopFastDiv, fastLoopBtn));

            normalLoadBtn.addEventListener('click', () => setupImages(false));
            lazyLoadBtn.addEventListener('click', () => setupImages(true));
            
            resetAllDemosBtn.addEventListener('click', resetAllDemos);
        });
    </script>
</body>
</html>
